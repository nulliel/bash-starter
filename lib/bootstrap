#!/usr/bin/env bash

##
# Prevent the script from being executed directly.
#
# There is no reason to execute this script directly as
# it does not do anything on its' own.
##
if [[ -z "$0" ]] || [[ "$0" =~ "bash" ]] || [[ "$0" =~ "-bash" ]]; then
    printf "[\e[1;91mERROR\e[0m] This script should not be executed directly\n" 1>&2
    return
fi

################################################################################
## Configs
################################################################################
if [[ -z "${BOOTSTRAP_DIR}" ]]; then
    printf "[\e[1;91mERROR\e[0m] BOOTSTRAP_DIR is not set\n" 1>&2
    exit 1
fi

declare -g CACHE_DIR="${BOOTSTRAP_DIR}/.cache"
declare -g BASH_STARTER_VERSION="${BASH_STARTER_VERSION:-master}"

################################################################################
## Debugging
################################################################################
export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

set -o errexit  # Exit when a command returns a non-zero status code
set -o nounset  # Exit when an unset variable is used
set -o pipefail # Exit when a command fails in a pipe. eg. command_will_fail | piped_command

################################################################################
## Cache
################################################################################
##
# Returns whether the cache is enabled.
#
# The cache is enabled by default but can be disabled
# by setting the `DISABLE_CACHE' environment variable
# to any value.
#
# Returns:
#
#   0 :: The cache is enabled
#   1 :: The cache is disabled
##
function Bootstrap::IsCacheEnabled()
{
    if [[ -n "${DISABLE_CACHE:-}" ]]; then
        return 1
    fi
}

################################################################################
## Import Aliases
################################################################################
shopt -s expand_aliases

alias import="Import::Main"
alias source="Import::Main"
alias .="Import::Main"

################################################################################
## Import
################################################################################
declare -ag IMPORT_SOURCES=(
    "https://raw.githubusercontent.com/nulliel/bash-starter/${BASH_STARTER_VERSION}/lib/modules"
    "${ADDITIONAL_IMPORT_SOURCES[@]}"
)

declare -a IMPORT_HOOKS=()
declare -a IMPORTED_FILES=()

if Bootstrap::IsCacheEnabled; then
    IMPORT_SOURCES=("${CACHE_DIR}" "${IMPORT_SOURCES[@]}")
fi


##
# Attempts to import a file.
#
# If any hook returns a non-zero status code, the
# module will not be imported.
#
# Arguments:
#
#   $1 :: The package to import
##
Import::Main()
{
    local package="${1}"
    local importFile="${CACHE_DIR}/${package}"

    if Import::IsLoaded "${package}"; then
        return 0
    fi

    if ! Bootstrap::IsCacheEnabled; then
        importFile="$(mktemp)"
    fi

    Import::System "${package}" || Import::Sources "${package}" "${importFile}"

    if [[ ! -f "${importFile}" ]]; then
        printf "[\e[1;91mERROR\e[0m] Unable to import package '%s'\n" "${package}" 1>&2
        exit 1
    fi

    IMPORTED_FILES+=("${package}")

    if Import::RunHooks "${importFile}"; then
        builtin source "${importFile}"
    fi
}

##
# Attempts to import a file from the filesystem.
#
# A file will attempt to be loaded from the filesystem if it
# begins with either `/` or `./`
#
# Arguments:
#
#   $1 :: The package name
#
# Returns:
#
#  0 :: The file was imported
#  1 :: The file was not imported
##
Import::System()
{
    local package="${1}"

    if [[ "${package}" != "/"* && "${package}" != "./"* ]]; then
        return 1
    fi

    if [[ ! -f "${package}" ]]; then
        return 1
    fi
}

##
# Attempts to import a file from one of the sources defined
# in `IMPORT_SOURCES`.
#
# Arguments:
#
#   $1 :: The package name
#   $2 :: The location to save the cached file
#
# Returns:
#
#  0 :: The file was imported
#  1 :: The file was not imported
##
Import::Sources()
{
    local package="${1}"
    local cacheFile="${2}"

    for source in "${IMPORT_SOURCES[@]}"; do
        if [[ "${source}" == "http://"* || "${source}" == "https://"* ]]; then
            if Import::HTTP "${source}" "${package}" "${cacheFile}"; then
                return 0
            fi
        elif [[ "${source}" == "/"* || "${source}" == "./"* ]]; then
            if Import::System "${source}/${package}"; then
                return 0
            fi
        else
            printf "[\e[1;91mERROR\e[0m] Unknown import source '%s'\n" "${source}" 1>&2
            exit 1
        fi
    done
}

##
# Attempts to import a file from a HTTP URL.
#
# Arguments:
#
#   $1 :: The base URL to download from
#   $2 :: The package name (url extension) to download
#   $3 :: The path to save the downloaded file to
#
# Returns:
#
#   0 :: The file was downloaded successfully
#   1 :: The file failed to download
##
Import::HTTP()
{
    local source="${1}"
    local package="${2}"
    local outFile="${3}"

    if [[ ! -d "$(dirname "${outFile}")" ]]; then
        mkdir -p "$(dirname "${outFile}")"
    fi

    if command -v curl 1>/dev/null 2>&1; then
        curl --fail -sL --retry 3 -H "Cache-Control: no-cache" -o "${outFile}" "${source}/${package}" || return 1
    else
        wget -t 3 -O - -o "${outFile}" "${source}/${package}" || return 1
    fi
}

##
# Adds an import hook.
#
# Import hooks allow user-defined functions to handle the
# final import process.
#
# An import hook will be passed the full path to a file
# being imported. If the function returns 0 the file will
# be imported. If the function returns any other value, the
# file will not be imported.
#
# This allows a function to act as an independant processor in
# which it can return 0 and perform its' own import.
#
# This is useful for the module system outlined in core/module
#
# Arguments:
#
#   $1 :: The function to add as an import hook
##
Import::AddHook()
{
    local functionName="$1"

    for element in "${IMPORT_HOOKS[@]}"; do
        if [[ "${element}" == "${functionName}" ]]; then
            printf "[\e[1;91mERROR\e[0m] Attempted to register hook '%s' twice\n" \
                   "${functionName}" 1>&2
            exit 1
        fi
    done

    IMPORT_HOOKS+=("${functionName}")
}

##
# Runs all `IMPORT_HOOKS` against a provided `localFile`
#
# See `Import::AddHook` for information on hooks.
#
# Arguments:
#
#   $1 :: The file to run hooks against
#
# Return:
#
#   0 :: If the file should be imported
#   1 :: If the file should not be imported
##
Import::RunHooks()
{
    local localFile="${1}"

    for hook in "${IMPORT_HOOKS[@]}"; do
        if ! "${hook}" "${localFile}"; then
            return 1
        fi
    done

    return 0
}

##
# Returns whether an import has already been loaded.
#
# Arguments:
#
#   $1 :: The package name to check
#
# Return:
#
#   0 :: The package has been loaded
#   1 :: The package has not been loaded
##
Import::IsLoaded()
{
    local package="${1}"

    for file in "${IMPORTED_FILES[@]}"; do
        if [[ "${file}" == "${package}" ]]; then
            return 0
        fi
    done

    return 1
}

################################################################################
## Bootstrap
################################################################################
##
# Ensures that the library is only loaded once.
#
# Multiple attempts to load the library will result in an error
# and exit.
##
Bootstrap::Load()
{
    if [[ "${__BS__BOOTSTRAP:-1}" -eq 0 ]]; then
        printf "[\e[1;91mERROR\e[0m] Attempted to bootstrap multiple times\n" 1>&2
        exit 1
    fi

    readonly __BS__BOOTSTRAP=0
}

##
# When scripts are called, their working directory is the directory in which
# they were called, not the location they reside.
#
# This causes issues when including local files, as you may not be in the
# directory you expect.
#
# This remedies this issue by changing the directory to the folder in which the
# called script resides.
#
# Note: greadlink is an osx command
#
# Arguments:
#
#   $1 :: The path to resolve
#
# Returns:
#
#   PRINT :: The real path of the provided path
##
Bootstrap::ResolvePath()
{
    $(type -p greadlink readlink | head -1) -f "$1"
}

Bootstrap::Main()
{
    Bootstrap::Load

    ############################################################################
    ## Default Modules
    ############################################################################
    mkdir -p "${CACHE_DIR}"

    import "core/coproc"
    import "core/module"
    # import "core/colors"
    # import "console"

    ############################################################################
    ## Paths
    ############################################################################
    declare -g SCRIPT_ROOT
    declare -g SCRIPT_SELF

    SCRIPT_ROOT="$(dirname "$(Bootstrap::ResolvePath "$0")")"
    SCRIPT_SELF="$(dirname "$(Bootstrap::ResolvePath "${BASH_SOURCE[0]}")")"

    readonly SCRIPT_ROOT
    readonly SCRIPT_SELF
}

Bootstrap::Main "$@"
